\documentclass[a4paper, 12pt]{article} % a4 is 210mm x 297mm
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{fancyvrb}
\usepackage{ifpdf}
\ifpdf
 \usetikzlibrary{patterns}
\fi
\lstset { %
    language=C++
}

% redefine \VerbatimInput
\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}%
{fontsize=\footnotesize,
 %
 frame=lines,  % top and bottom rule only
 framesep=2em, % separation between frame and text
 rulecolor=\color{Gray},
 %
%  label=\fbox{\color{Black}data.txt},
 labelposition=topline,
 %
 commandchars=\|\(\), % escape character and argument delimiters for
                      % commands within the verbatim
 commentchar=*        % comment character
}

\title{Using Pseudo-Random Numbers Repeatably in a Fine-Grain Multithreaded Simulation}
\author{Dmitry Savin}
\date{\today}

\usepackage[utf8]{inputenc}

\newcommand{\MD}{Merkle-Damg\r{a}rd}

\begin{document}
 \maketitle
 
 \abstract
  Because of the transition from event-level parallelism in Geant4 to dynamical multithreading in GeantV the order in which tracks are processed becomes non-deterministic.
  Thus to maintain reproducibility one needs to associate the random generator state with the track itself and the worker thread currently processing the track.
  To be reproducible from the beginning of the event, this state can only depend on the pedigree of the track.
%   To reduce overhead the pedigree is stored in a hashed form, which is sufficient because the reverse reconstruction is unneeded.
  Calculation of the hashed pedigree of a track using the hashed pedigree of the parent track makes the hashing algorithm a \MD\ construct with well-studied properties.
  
  We implement this construction using a 64-bit hash and standard hash with boost\_combine as the compression function operating on the number of the track among siblings as the input message blocks.
  We use the hashed pedigree as the seed for a CLHEP random number engine at the beginning of processing of each track in a Geant4 simulation.
  We show the reproducibility of the results under different track stacking order and their agreement with the results with the default random number generation.
  We show that the performance overhead is negligible for most of the random number generators except for those that have a complex internal state.
  
 \newpage
 \tableofcontents
 \newpage
  
 \section{Introduction}
  \subsection{Monte Carlo simulation}
  \subsection{Geant4}
   Geant4~\cite{AGOSTINELLI2003250, 1610988, ALLISON2016186} is a toolkit for the simulation of the passage of particles through matter.
   
   
   \cite{GEANT4-MT}
   Each thread has an instance of random number generator engine.
   
  \subsection{GeantV}
   GeantV~\cite{1742-6596-523-1-012004} is a project aimed at increasing the performance of HEP simulations.
   It is achieved by utilizing massive parallelism of modern hardware and accelerators, such as GPGPUs and Intel Xeon Phi coprocessors.
   While different threads may operate independently, to make use of vectorization within thread one must have data layout suitable for SIMD (Single Instruction Multiple Data) operations.
   Thus the tracks with similar properties (particle type, energy, enclosing volume) must be regrouped into "baskets".
   Then the baskets are processed by worker threads, which readiness depends on running conditions and cannot be deterministic.
   So the tracks in one event or even parts of the same track are processed by different threads.
   Thus to assure reproducibility the pseudo-random engine state must be associated with the track itself;
   and state of the secondary track has to be a deterministic function of the parent track.
   This is similar to the mechanism of pedigrees~\cite{Leiserson:2012:DPR:2145816.2145841, Leiserson:2012:DPR:2370036.2145841} for repeatable parallel random-number generators proposed for Intel Cilk platform, which gave the idea for this work.
   
  \subsection{Pedigrees}
   Pedigrees are deterministic labels for the executed instructions in a dthreaded program execution that partition the instructions into valid strands in such way, that
   \begin{itemize}
    \item each strand includes instructions with the same pedigree,
    \item the pedigree of any instruction does not depend on how the program is scheduled on multiple processors.
   \end{itemize}
   These requirements guarantee that pedigrees deterministically identify strands irrespective of scheduling.
   A random number can be generated by hashing the pedigree, which can be used to initialize a substream of the random number generator.
   The pedigree can be represented as a sequence of the instruction rank followed by the ranks (number of other daughter instruction generated earlier) of its ancestors.
   
   In Geant case is translates into the rank of a track equal to the number of secondary tracks generated by the parent before it.
   We implement pedigree calculation in Geant4 as a prototype to be further ported to GeantV.
   
%    \cite{Mor2014}
  
 \section{Geant4-based prototype}
  \begin{figure}
   \scalebox{.5}{\input{damgard}}
   \caption{Pedigree hash calculation and usage in the Geant4-based prototype.}
  \end{figure}
  To check the results of setting the random number generator on a per-track basis we add additional state to G4Track.
  For compatibility with different random number generators and minimal overhead the additional state is a single number that is used as the seed for the random number generator at the beginning of tracking.
  The stored number represents the hashed pedigree of the track.
  The hashed pedigree is used to seed the random number generator at the beginning of processing each track.
  Since in Geant4 the track is processed by the thread from start to the end, it is unnecessary to store a copy of the random number generator state in the track.
 
  \subsection{Hash calculation}
   Because when the secondary track is created not full pedigree of its parent but only the hash is available, the hashing algorithm is similar to \MD\ construct~\cite{Damgard1990, Merkle1990} with more relaxed requirements compared to cryptographic uses.
   At each secondary track creation a compression function is used to calculate the hashed pedigree of the secondary track from the hashed pedigree of its parent and the number of already created siblings.
   To assure cryptographic quality one could use 256-bit hash and SHA-256 (wich is a \MD\ construct itself) as the compression function, but since the simulated physics and seeding of the random number generator add more complexity, we implemented a simpler scheme.
   The hash is a 64-bit integer, and the compression function is standard hash followed by has\_combine from boost.
   The initial vector is generated by the random engine at the beginning of the event.
%    TODO put code in the appendix
 
 \subsection{Counter-based Pseudo-Random Number Generators}
  To reduce the overhead from frequent generator seeding one can use a generator with a simple transition function and compact state but a more complex output function. % Needs explanation and a line in the abstract
  Counter-based Pseudo-Random Number Generators are the ultimate example of such generators with the transition function is a simple increment and the output is a block cipher.
  To take advantage of an already tested solution we provide a HepRandomEngine wrapper for Philox1x64 and Threefry1x64 generators from Random123 library. % TODO cite
  They both have a 64-bit counter an thus generate 64-bit output sufficient to generate a double precision floating point value in $[0;1)$ range - the most frequent use case in Geant4.
  Also they both use an additional key, which allows easy spawning of independent streams.
  Other variations of Philox and Threefry (as well as AES-based) generators provided in this library seem excessive because of bigger output size, but may be more efficient when simultaneously generating many random numbers for vector computation.
 
%  \subsection{Auxiliary classes}
 
 \subsection{Testing}
  \subsubsection{Reproducibility}
   To test the reproducibility we add a runtime capability to turn on and off setting seeds at the start of tracking via a Geant4 macro command.
   We modify a basic example to process tracks either in the default (first in last out) order, or in a non-deterministic depending on the standard random device.
 %   We also add the reseeding capability at user level via Tracking and Stepping actions.
   To compare the results we calculate p-value between the output histograms (which represent the number of tracks in each generation) from different runs.
   The full test macros are presented in Appendix~\ref{TESTMACROS}.
  
   To check the sensitivity of the test we calculate the p-values with the default tracking order for runs with the same engine and different seeds set via a macro command.
   We find that for runs with the same seeds the p-value equals $1$, and for runs with different seeds the p-value $p\ <\ 1$ (less than $10^{-10}$ for this histogram because of correlated bins and high statistics), thus the test is sensitive to the random numbers used during the simulation.
   The p-value for runs with random tracking order $p\ <\ 1$, thus the test is sensitive to the tracking order.
   The p-value for runs with reseeding at the beginning of tracking are equal 1 with any tracking order, thus the pedigrees do assure reproducibility independent of tracking order.
 %   Both reseeding at user and toolkit level 
   The full test results are presented in Appendix~\ref{TESTRESULTS}.
  \subsubsection{Physical results}
   \begin{figure}
    \label{GAMMASPECTRUM}
    \scalebox{.8}{\input{graphiteGamma}}
    \caption{Neutron induced gamma spectrum from a graphite sample with different random engines.}
   \end{figure}
   To assess the physical results we compare the output of Hadr06 standard example with different random number generators.
   The macro used was derived from graphite.mac by multiplying the statistics by ten.
   Figure~\ref{GAMMASPECTRUM} shows the spectrum of gamma rays emitted from a graphite sample.
   The most intensive line at 4.4 MeV corresponds to the first excited level of $^{12}C$.
   The p-values for pairs of histograms produced with different engines are in the range $0.1 - 0.9$.
   It indicates that the results with different generators are in general agreement, including the new counter-based ones.
   For full results see Appendix~\ref{TESTRESULTS}.
  
  \subsubsection{Performance}
  \begin{figure}
   \label{USERTIME}
   \scalebox{.8}{\input{mean}}
   \caption{User run time with (Y axis) and without (X axis) reseeding.}
  \end{figure}
 
 
 \section{Conclusion}
 
 \section{Acknowledgements}
  Development sponsored by Google in Google Summer of Code 2017 under supervision of John Apostolakis and Sandro Wenzel.
 
 \newpage
 \bibliographystyle{plain}
 \bibliography{gsocPreprint}
 
 \appendix
  \section{Test macros}
   \label{TESTMACROS}
   
   \VerbatimInput{runTr.mac}
   
   \VerbatimInput{runSomeTimes.mac}
  
  \section{Test results}
   \label{TESTRESULTS}
   \subsection{Reproducibility}
   
   \VerbatimInput{script.out}
   
   \subsection{Physical results}

    Debug build:\\
    \begin{tabular}{ l c c c c r }
     1 & 0.22 & 0.83 & 0.79 & 0.12 & 0.57 \\
     0.22 & 1 & 0.19 & 0.42 & 0.89 & 0.8 \\
     0.83 & 0.19 & 1 & 0.68 & 0.5 & 0.79 \\
     0.79 & 0.42 & 0.68 & 1 & 0.29 & 0.79 \\
     0.12 & 0.89 & 0.5 & 0.29 & 1 & 0.76 \\
     0.57 & 0.8 & 0.79 & 0.79 & 0.76 & 1 \\
    \end{tabular}
   
    Release build with 10x statistics:\\
    \begin{tabular}{ l c c c c r }
     1 & 0.44 & 0.07 & 0.39 & 0.12 & 0.5 \\
     0.44 & 1 & 0.52 & 0.97 & 0.79 & 0.93 \\
     0.07 & 0.52 & 1 & 0.33 & 0.2 & 0.56 \\
     0.39 & 0.97 & 0.33 & 1 & 0.85 & 0.83 \\
     0.12 & 0.79 & 0.2 & 0.85 & 1 & 0.42 \\
     0.5 & 0.93 & 0.56 & 0.83 & 0.42 & 1 \\
    \end{tabular}
    
    With reseeding activated:\\
    \begin{tabular}{ l c c c c r }
     1 & 0.91 & 0.6 & 0.33 & 0.26 & 0.35 \\
     0.91 & 1 & 0.02 & 0.85 & 0.82 & 0.5 \\
     0.6 & 0.02 & 1 & 0.1 & 0.26 & 0.76 \\
     0.33 & 0.85 & 0.1 & 1 & 0.84 & 0.57 \\
     0.26 & 0.82 & 0.26 & 0.84 & 1 & 0.68 \\
     0.35 & 0.5 & 0.76 & 0.57 & 0.68 & 1 \\
    \end{tabular}
    
   \subsection{Performance}
    
    \scalebox{.8}{\input{mersenne-plain}}
    \scalebox{.8}{\input{ranlux64-plain}}
    \scalebox{.8}{\input{philox-plain}}
    \scalebox{.8}{\input{threefry-plain}}
    \scalebox{.8}{\input{ranecu-plain}}
    \scalebox{.8}{\input{mixmax-plain}}
    
% hadr06 p-values  
\end{document}
