\documentclass[a4paper, titlepage, 12pt]{article} % a4 is 210mm x 297mm
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++
}


\title{Using Pseudo-Random Number Repeatably in a Fine-Grain Multithreaded Simulation}
\author{Dmitry Savin}
\date{\today}

\usepackage[utf8]{inputenc}

\newcommand{\MD}{Merkle-Damg\r{a}rd}

\begin{document}
 \maketitle
 
 \abstract
  Because of the transition from event-level parallelism in Geant4 to dynamical multithreading in GeantV the order in which tracks are processed becomes non-deterministic.
  Thus to maintain reproducibility one needs to associate the random generator state with the track itself and the worker thread currently processing the track.
  To be reproducible from the beginning of the event, this state can only depend on the pedigree of the track.
  To reduce overhead the pedigree is stored in a hashed form, which is sufficient because the reverse reconstruction is unneeded.
  Calculation of the hashed pedigree of a track using the hashed pedigree of the parent track makes the hashing algorithm a \MD\ construct with well-studied properties.
  
  We implement this construction using a 64-bit hash and standard hash with boost\_combine as the compression function operating on the number of the track among siblings as the input message blocks.
  We use the hashed pedigree as the seed for a CLHEP random number engine at the beginning of processing of each track in a Geant4 simulation.
  We show the reproducibility of the results under different track stacking order and their agreement with the results with the default random number generation.
  We show that the performance overhead is negligible for most of the random number generators except for those that have a complex internal state.
  
 \section{Introduction}
  \subsection{Monte Carlo simulation}
  \subsection{Geant4}
   Geant4~\cite{AGOSTINELLI2003250, 1610988, ALLISON2016186} is a toolkit for the simulation of the passage of particles through matter.
   
   
   \cite{GEANT4-MT}
   Each thread has an instance of random number generator engine.
   
  \subsection{GeantV}
   GeantV~\cite{1742-6596-523-1-012004} is a project aimed at increasing the performance of HEP simulations.
   It is achieved by utilizing massive parallelism of modern hardware and accelerators, such as GPGPUs and Intel Xeon Phi coprocessors.
   While different threads may operate independently, to make use of vectorization within thread one must have data layout suitable for SIMD (Single Instruction Multiple Data) operations.
   Thus the tracks with similar properties (particle type, energy, enclosing volume) must be regrouped into "baskets".
   Then the baskets are processed by worker threads, which readiness depends on running conditions and cannot be deterministic.
   So the tracks in one event or even parts of the same track are processed by different threads.
   Thus to assure reproducibility the pseudo-random engine state must be associated with the track itself;
   and state of the secondary track has to be a deterministic function of the parent track.
   This is similar to the mechanism of pedigrees~\cite{Leiserson:2012:DPR:2145816.2145841, Leiserson:2012:DPR:2370036.2145841} for repeatable parallel random-number generators proposed for Intel Cilk platform, which gave the idea for this work.
   
  \subsection{Pedigrees}
   Pedigrees are deterministic labels for the executed instructions in a dthreaded program execution that partition the instructions into valid strands in such way, that
   \begin{itemize}
    \item each strand includes instructions with the same pedigree
    \item each strand includes instructions with the same pedigree and the pedigree of any instruction does not depend on how the program is scheduled on multiple processors.
   \end{itemize}
   These requirements guarantee that pedigrees deterministically identify strands irrespective of scheduling.
   A random number can be generated by hashing the pedigree, which can be used to initialize a substream of the random number generator.
   The pedigree can be represented as a sequence of the instruction rank followed by the ranks (number of other daughter instruction generated earlier) of its ancestors.
   
   In Geant case is translates into the rank of a track equal to the number of secondary tracks generated by the parent before it.
   We implement pedigree calculation in Geant4 as a prototype to be further ported to GeantV.
   
%    \cite{Mor2014}
  
 \section{Geant4 prototype}
  To check the results of setting the random number generator on a per-track basis we add additional state to G4Track.
  For compatibility with different random number generators and minimal overhead the additional state is a single number that is used as the seed for the random number generator at the beginning of tracking.
 
  \subsection{Hash calculation}
  
   \MD\ \cite{Damgard1990, Merkle1990}
   
 \section{Counter-based Pseudo-Random Number Generators}
 
 
 \section{Testing}
 
 \section{Performance}
 
 
 \section{Conclusion}
 
 \section{Acknowledgements}
  Development sponsored by Google in Google Summer of Code 2017 under supervision of John Apostolakis and Sandro Wenzel.
 
 \bibliographystyle{plain}
 \bibliography{gsocPreprint}
 
 \appendix
  
\end{document}
